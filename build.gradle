import org.apache.tools.ant.filters.ReplaceTokens

plugins {
    id 'java'
    id 'scala'
    id 'org.springframework.boot' version '3.4.5'
    id 'io.spring.dependency-management' version '1.1.7'
    id 'org.hibernate.orm' version '6.6.13.Final'
    id 'org.graalvm.buildtools.native' version '0.10.6'
    id 'com.dorongold.task-tree' version '2.1.1'
    id 'io.freefair.aspectj.post-compile-weaving' version '8.13.1'
}

// Configure GraalVM Native Image plugin: consume generated config when building native
// (we'll collect config during tests via -agentlib on the test JVMs below)
ext.nativeImageConfigDir = layout.buildDirectory.dir('native-image-config').get().asFile.absolutePath
graalvmNative {
  binaries {
    main {
      buildArgs.add("-H:ConfigurationFileDirectories=${nativeImageConfigDir}")
    }
  }
}

group = 'net.edmacdonald'
version = '0.0.1-SNAPSHOT'

java {
    toolchain {
        languageVersion = JavaLanguageVersion.of(21)
    }
}

scala {
    scalaVersion = "3.6.4"
}

springBoot {
    mainClass = 'net.edmacdonald.jvmcli.JvmcliApplication'
}

sourceSets {
    main {
        scala {
            srcDirs = ['src/main/scala', 'src/main/java']
        }
        java {
            srcDirs = []
        }
        resources {
            srcDirs = ['src/main/resources', 'src/main/resources-filtered']
        }
    }
}

processResources {
    filesMatching('src/main/resources-filtered/**') {
        filter(ReplaceTokens, tokens: [
            'key1': 'value1',
            'key2': 'value2'
        ])
    }
}

repositories {
    mavenCentral()
}

dependencies {
    implementation 'org.springframework.boot:spring-boot-starter-data-jpa'
    inpath 'info.picocli:picocli:4.7.7'
    implementation 'org.liquibase:liquibase-core'
    implementation 'org.aspectj:aspectjrt:1.9.22'
    annotationProcessor 'info.picocli:picocli-codegen:4.7.7'
    developmentOnly 'org.springframework.boot:spring-boot-devtools'
    runtimeOnly 'com.h2database:h2'
    testImplementation 'org.springframework.boot:spring-boot-starter-test'
    testImplementation 'org.assertj:assertj-core:3.26.3'
    testRuntimeOnly 'org.junit.platform:junit-platform-launcher'
}

compileJava {
    options.compilerArgs += ["-Aproject=${project.group}/${project.name}"]
}

hibernate {
    enhancement {
        enableAssociationManagement = true
    }
}

tasks.named('compileJava') {
    enabled =false
}

tasks.named('test') {
    useJUnitPlatform()

    // Collect GraalVM Native Image config whilst running tests.
    // Big incentive here to have your tests cover all your code.
    jvmArgs "-agentlib:native-image-agent=config-output-dir=${nativeImageConfigDir}"
}

tasks.withType(Test).configureEach {
    testLogging {
        // Show System.out and System.err from tests in the console
        showStandardStreams = true
        // Also log which tests passed/skipped/failed and show full stack traces
        events 'passed', 'skipped', 'failed'
        exceptionFormat 'full'
    }
}

// Ensure native image build compiles after test-generated configs are available
tasks.named('nativeCompile') { dependsOn 'test' }
tasks.named('nativeBuild')   { dependsOn 'test' }

// Mildly concerned as to why I have to add this... but I periodically get errors like:
// "Entry net/edmacdonald/jvmcli/repository/CommandInvocationRepository.class is a duplicate but no duplicate handling strategy has been set."
// if I don't.
tasks.withType(Jar).configureEach {
    duplicatesStrategy = DuplicatesStrategy.EXCLUDE
}